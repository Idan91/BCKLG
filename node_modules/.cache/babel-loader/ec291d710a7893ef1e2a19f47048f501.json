{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/Idan/Documents/GitHub/Idan91/BCKLG/bcklg/node_modules/@babel/runtime/regenerator\");\n\nvar _filter = require('lodash/filter');\n\nvar find = require('lodash/find');\n\nvar _require = require('./constats'),\n    API_ROOT = _require.API_ROOT;\n\nvar pather = function pather(endpoint) {\n  return function (item, section) {\n    var query = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    return \"\".concat(API_ROOT, \"/\").concat(endpoint).concat(item ? \"/\".concat(item) : '').concat(section ? \"/\".concat(section) : '').concat(query);\n  };\n};\n\nexports.pather = pather; // Fetches pages for paginated enpoints\n\nvar fetchPage = function fetchPage(fetcher) {\n  return function (url, formatter) {\n    return function _callee() {\n      var json, formatted;\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _regeneratorRuntime.awrap(fetcher.get(url));\n\n            case 2:\n              json = _context.sent;\n              formatted = json.results.map(formatter);\n              return _context.abrupt(\"return\", collection(fetcher)(json, formatted, formatter));\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      });\n    };\n  };\n};\n\nexports.fetchPage = fetchPage;\n\nvar single = function single(fetcher) {\n  return function (json, formatted) {\n    return {\n      raw: function raw() {\n        return json;\n      },\n      get: function get(key) {\n        return key ? formatted[key] : formatted;\n      }\n    };\n  };\n};\n\nexports.single = single;\n\nvar collection = function collection(fetcher) {\n  return function (json, formatted, formatter) {\n    return {\n      raw: function raw() {\n        return json.results;\n      },\n      get: function get() {\n        return formatted;\n      },\n      count: function count() {\n        return json.count;\n      },\n      filter: function filter(predicate) {\n        return _filter(formatted, predicate);\n      },\n      find: function find(predicate) {\n        return _filter(formatted, predicate);\n      },\n      findOne: function findOne(predicate) {\n        return find(formatted, predicate);\n      },\n      next: json.next ? fetchPage(fetcher)(json.next, formatter) : function () {},\n      previous: json.previous ? fetchPage(fetcher)(json.next, formatter) : function () {}\n    };\n  };\n};\n\nexports.collection = collection;","map":{"version":3,"sources":["/Users/Idan/Documents/GitHub/Idan91/BCKLG/bcklg/node_modules/rawger/src/utils.js"],"names":["filter","require","find","API_ROOT","pather","endpoint","item","section","query","exports","fetchPage","fetcher","url","formatter","get","json","formatted","results","map","collection","single","raw","key","count","predicate","findOne","next","previous"],"mappings":"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","sourcesContent":["const filter = require('lodash/filter');\nconst find = require('lodash/find');\nconst { API_ROOT } = require('./constats');\n\nconst pather = endpoint => (item, section, query = '') =>\n  `${API_ROOT}/${endpoint}${item ? `/${item}` : ''}${\n    section ? `/${section}` : ''\n  }${query}`;\n\nexports.pather = pather;\n\n// Fetches pages for paginated enpoints\nconst fetchPage = fetcher => (url, formatter) => async () => {\n  const json = await fetcher.get(url);\n\n  const formatted = json.results.map(formatter);\n  return collection(fetcher)(json, formatted, formatter);\n};\n\nexports.fetchPage = fetchPage;\n\nconst single = fetcher => (json, formatted) => ({\n  raw: () => json,\n  get: key => (key ? formatted[key] : formatted)\n});\n\nexports.single = single;\n\nconst collection = fetcher => (json, formatted, formatter) => ({\n  raw: () => json.results,\n  get: () => formatted,\n  count: () => json.count,\n  filter: predicate => filter(formatted, predicate),\n  find: predicate => filter(formatted, predicate),\n  findOne: predicate => find(formatted, predicate),\n  next: json.next ? fetchPage(fetcher)(json.next, formatter) : () => {},\n  previous: json.previous ? fetchPage(fetcher)(json.next, formatter) : () => {}\n});\n\nexports.collection = collection;\n"]},"metadata":{},"sourceType":"script"}