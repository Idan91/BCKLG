{"ast":null,"code":"const filter = require('lodash/filter');\n\nconst find = require('lodash/find');\n\nconst {\n  API_ROOT\n} = require('./constats');\n\nconst pather = endpoint => (item, section, query = '') => `${API_ROOT}/${endpoint}${item ? `/${item}` : ''}${section ? `/${section}` : ''}${query}`;\n\nexports.pather = pather; // Fetches pages for paginated enpoints\n\nconst fetchPage = fetcher => (url, formatter) => async () => {\n  const json = await fetcher.get(url);\n  const formatted = json.results.map(formatter);\n  return collection(fetcher)(json, formatted, formatter);\n};\n\nexports.fetchPage = fetchPage;\n\nconst single = fetcher => (json, formatted) => ({\n  raw: () => json,\n  get: key => key ? formatted[key] : formatted\n});\n\nexports.single = single;\n\nconst collection = fetcher => (json, formatted, formatter) => ({\n  raw: () => json.results,\n  get: () => formatted,\n  count: () => json.count,\n  filter: predicate => filter(formatted, predicate),\n  find: predicate => filter(formatted, predicate),\n  findOne: predicate => find(formatted, predicate),\n  next: json.next ? fetchPage(fetcher)(json.next, formatter) : () => {},\n  previous: json.previous ? fetchPage(fetcher)(json.next, formatter) : () => {}\n});\n\nexports.collection = collection;","map":{"version":3,"sources":["/Users/Idan/Projects/Dev/GitHub/BCKLG/node_modules/rawger/src/utils.js"],"names":["filter","require","find","API_ROOT","pather","endpoint","item","section","query","exports","fetchPage","fetcher","url","formatter","json","get","formatted","results","map","collection","single","raw","key","count","predicate","findOne","next","previous"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,aAAD,CAApB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAeF,OAAO,CAAC,YAAD,CAA5B;;AAEA,MAAMG,MAAM,GAAGC,QAAQ,IAAI,CAACC,IAAD,EAAOC,OAAP,EAAgBC,KAAK,GAAG,EAAxB,KACxB,GAAEL,QAAS,IAAGE,QAAS,GAAEC,IAAI,GAAI,IAAGA,IAAK,EAAZ,GAAgB,EAAG,GAC/CC,OAAO,GAAI,IAAGA,OAAQ,EAAf,GAAmB,EAC3B,GAAEC,KAAM,EAHX;;AAKAC,OAAO,CAACL,MAAR,GAAiBA,MAAjB,C,CAEA;;AACA,MAAMM,SAAS,GAAGC,OAAO,IAAI,CAACC,GAAD,EAAMC,SAAN,KAAoB,YAAY;AAC3D,QAAMC,IAAI,GAAG,MAAMH,OAAO,CAACI,GAAR,CAAYH,GAAZ,CAAnB;AAEA,QAAMI,SAAS,GAAGF,IAAI,CAACG,OAAL,CAAaC,GAAb,CAAiBL,SAAjB,CAAlB;AACA,SAAOM,UAAU,CAACR,OAAD,CAAV,CAAoBG,IAApB,EAA0BE,SAA1B,EAAqCH,SAArC,CAAP;AACD,CALD;;AAOAJ,OAAO,CAACC,SAAR,GAAoBA,SAApB;;AAEA,MAAMU,MAAM,GAAGT,OAAO,IAAI,CAACG,IAAD,EAAOE,SAAP,MAAsB;AAC9CK,EAAAA,GAAG,EAAE,MAAMP,IADmC;AAE9CC,EAAAA,GAAG,EAAEO,GAAG,IAAKA,GAAG,GAAGN,SAAS,CAACM,GAAD,CAAZ,GAAoBN;AAFU,CAAtB,CAA1B;;AAKAP,OAAO,CAACW,MAAR,GAAiBA,MAAjB;;AAEA,MAAMD,UAAU,GAAGR,OAAO,IAAI,CAACG,IAAD,EAAOE,SAAP,EAAkBH,SAAlB,MAAiC;AAC7DQ,EAAAA,GAAG,EAAE,MAAMP,IAAI,CAACG,OAD6C;AAE7DF,EAAAA,GAAG,EAAE,MAAMC,SAFkD;AAG7DO,EAAAA,KAAK,EAAE,MAAMT,IAAI,CAACS,KAH2C;AAI7DvB,EAAAA,MAAM,EAAEwB,SAAS,IAAIxB,MAAM,CAACgB,SAAD,EAAYQ,SAAZ,CAJkC;AAK7DtB,EAAAA,IAAI,EAAEsB,SAAS,IAAIxB,MAAM,CAACgB,SAAD,EAAYQ,SAAZ,CALoC;AAM7DC,EAAAA,OAAO,EAAED,SAAS,IAAItB,IAAI,CAACc,SAAD,EAAYQ,SAAZ,CANmC;AAO7DE,EAAAA,IAAI,EAAEZ,IAAI,CAACY,IAAL,GAAYhB,SAAS,CAACC,OAAD,CAAT,CAAmBG,IAAI,CAACY,IAAxB,EAA8Bb,SAA9B,CAAZ,GAAuD,MAAM,CAAE,CAPR;AAQ7Dc,EAAAA,QAAQ,EAAEb,IAAI,CAACa,QAAL,GAAgBjB,SAAS,CAACC,OAAD,CAAT,CAAmBG,IAAI,CAACY,IAAxB,EAA8Bb,SAA9B,CAAhB,GAA2D,MAAM,CAAE;AARhB,CAAjC,CAA9B;;AAWAJ,OAAO,CAACU,UAAR,GAAqBA,UAArB","sourcesContent":["const filter = require('lodash/filter');\nconst find = require('lodash/find');\nconst { API_ROOT } = require('./constats');\n\nconst pather = endpoint => (item, section, query = '') =>\n  `${API_ROOT}/${endpoint}${item ? `/${item}` : ''}${\n    section ? `/${section}` : ''\n  }${query}`;\n\nexports.pather = pather;\n\n// Fetches pages for paginated enpoints\nconst fetchPage = fetcher => (url, formatter) => async () => {\n  const json = await fetcher.get(url);\n\n  const formatted = json.results.map(formatter);\n  return collection(fetcher)(json, formatted, formatter);\n};\n\nexports.fetchPage = fetchPage;\n\nconst single = fetcher => (json, formatted) => ({\n  raw: () => json,\n  get: key => (key ? formatted[key] : formatted)\n});\n\nexports.single = single;\n\nconst collection = fetcher => (json, formatted, formatter) => ({\n  raw: () => json.results,\n  get: () => formatted,\n  count: () => json.count,\n  filter: predicate => filter(formatted, predicate),\n  find: predicate => filter(formatted, predicate),\n  findOne: predicate => find(formatted, predicate),\n  next: json.next ? fetchPage(fetcher)(json.next, formatter) : () => {},\n  previous: json.previous ? fetchPage(fetcher)(json.next, formatter) : () => {}\n});\n\nexports.collection = collection;\n"]},"metadata":{},"sourceType":"script"}