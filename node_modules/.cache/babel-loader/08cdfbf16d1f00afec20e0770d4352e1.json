{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/Idan/Documents/GitHub/Idan91/BCKLG/bcklg/node_modules/@babel/runtime/regenerator\");\n\nrequire('./fetchLoader');\n\nvar merge = require('lodash/merge');\n\nvar defaultHeaders = {\n  headers: {\n    'content-type': 'application/json',\n    'accept': 'application/json'\n  }\n};\n\nvar get = function get(cache, timeout, token) {\n  return function _callee(path) {\n    var options,\n        resp,\n        json,\n        timeoutID,\n        _args = arguments;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n            if (!(typeof cache[path] !== 'undefined')) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", cache[path].data);\n\n          case 3:\n            _context.next = 5;\n            return _regeneratorRuntime.awrap(fetch(path, merge(options, {\n              headers: {\n                token: token\n              }\n            }, defaultHeaders)));\n\n          case 5:\n            resp = _context.sent;\n            _context.next = 8;\n            return _regeneratorRuntime.awrap(resp.json());\n\n          case 8:\n            json = _context.sent;\n            // saves timeoutID for purging timers\n            timeoutID = setTimeout(function () {\n              delete cache[path];\n            }, timeout);\n            cache[path] = {\n              timeout: timeoutID,\n              data: json\n            };\n            return _context.abrupt(\"return\", json);\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    });\n  };\n};\n\nvar post = function post(token) {\n  return function _callee2(path, data) {\n    var options,\n        resp,\n        json,\n        _args2 = arguments;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n            _context2.next = 3;\n            return _regeneratorRuntime.awrap(fetch(path, merge(options, {\n              method: 'POST',\n              headers: {\n                token: \"Token \".concat(token)\n              },\n              body: JSON.stringify(data)\n            }, defaultHeaders)));\n\n          case 3:\n            resp = _context2.sent;\n            _context2.next = 6;\n            return _regeneratorRuntime.awrap(resp.json());\n\n          case 6:\n            json = _context2.sent;\n            return _context2.abrupt(\"return\", json);\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    });\n  };\n};\n\nvar patch = function patch(token) {\n  return function _callee3(path, data) {\n    var options,\n        resp,\n        json,\n        _args3 = arguments;\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n            _context3.next = 3;\n            return _regeneratorRuntime.awrap(fetch(path, merge(options, {\n              method: 'PATCH',\n              headers: {\n                token: \"Token \".concat(token)\n              },\n              body: JSON.stringify(data)\n            }, defaultHeaders)));\n\n          case 3:\n            resp = _context3.sent;\n            _context3.next = 6;\n            return _regeneratorRuntime.awrap(resp.json());\n\n          case 6:\n            json = _context3.sent;\n            return _context3.abrupt(\"return\", json);\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    });\n  };\n};\n\nmodule.exports = function (cache, timeout, token) {\n  return {\n    get: get(cache, timeout, token),\n    post: post(token),\n    patch: patch(token)\n  };\n};","map":{"version":3,"sources":["/Users/Idan/Documents/GitHub/Idan91/BCKLG/bcklg/node_modules/rawger/src/fetcher.js"],"names":["require","merge","defaultHeaders","headers","get","cache","timeout","token","path","options","data","fetch","resp","json","timeoutID","setTimeout","post","method","body","JSON","stringify","patch","module","exports"],"mappings":"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","sourcesContent":["require('./fetchLoader');\nconst merge = require('lodash/merge');\n\nconst defaultHeaders = {\n  headers: {\n    'content-type': 'application/json',\n    'accept': 'application/json'\n  }\n};\n\nconst get = (cache, timeout, token) => async (path, options = {}) => {\n  if (typeof cache[path] !== 'undefined') return cache[path].data;\n  \n  const resp = await fetch(path, merge(options, { headers: { token } }, defaultHeaders));\n  const json = await resp.json();\n\n  // saves timeoutID for purging timers\n  const timeoutID = setTimeout(() => { delete cache[path]; }, timeout);\n\n  cache[path] = {\n    timeout: timeoutID,\n    data: json\n  };\n  return json;\n}\n\nconst post = token => async (path, data, options = {}) => {\n  const resp = await fetch(path, merge(options, {\n    method: 'POST',\n    headers: { token: `Token ${token}` },\n    body: JSON.stringify(data)\n  }, defaultHeaders));\n  const json = await resp.json();\n  return json;\n}\n\nconst patch = token => async (path, data, options = {}) => {\n  const resp = await fetch(path, merge(options, {\n    method: 'PATCH',\n    headers: {\n      token: `Token ${token}`\n    },\n    body: JSON.stringify(data)\n  }, defaultHeaders));\n  const json = await resp.json();\n  return json;\n}\n\nmodule.exports = (cache, timeout, token) => ({\n  get: get(cache, timeout, token),\n  post: post(token),\n  patch: patch(token)\n});\n"]},"metadata":{},"sourceType":"script"}