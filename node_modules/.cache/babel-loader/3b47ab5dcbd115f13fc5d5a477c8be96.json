{"ast":null,"code":"require('./fetchLoader');\n\nconst merge = require('lodash/merge');\n\nconst defaultHeaders = {\n  headers: {\n    'content-type': 'application/json',\n    'accept': 'application/json'\n  }\n};\n\nconst get = (cache, timeout, token) => async (path, options = {}) => {\n  if (typeof cache[path] !== 'undefined') return cache[path].data;\n  const resp = await fetch(path, merge(options, {\n    headers: {\n      token\n    }\n  }, defaultHeaders));\n  const json = await resp.json(); // saves timeoutID for purging timers\n\n  const timeoutID = setTimeout(() => {\n    delete cache[path];\n  }, timeout);\n  cache[path] = {\n    timeout: timeoutID,\n    data: json\n  };\n  return json;\n};\n\nconst post = token => async (path, data, options = {}) => {\n  const resp = await fetch(path, merge(options, {\n    method: 'POST',\n    headers: {\n      token: `Token ${token}`\n    },\n    body: JSON.stringify(data)\n  }, defaultHeaders));\n  const json = await resp.json();\n  return json;\n};\n\nconst patch = token => async (path, data, options = {}) => {\n  const resp = await fetch(path, merge(options, {\n    method: 'PATCH',\n    headers: {\n      token: `Token ${token}`\n    },\n    body: JSON.stringify(data)\n  }, defaultHeaders));\n  const json = await resp.json();\n  return json;\n};\n\nmodule.exports = (cache, timeout, token) => ({\n  get: get(cache, timeout, token),\n  post: post(token),\n  patch: patch(token)\n});","map":{"version":3,"sources":["/Users/Idan/Projects/Dev/BCKLG/v2/BCKLG/bcklg/node_modules/rawger/src/fetcher.js"],"names":["require","merge","defaultHeaders","headers","get","cache","timeout","token","path","options","data","resp","fetch","json","timeoutID","setTimeout","post","method","body","JSON","stringify","patch","module","exports"],"mappings":"AAAAA,OAAO,CAAC,eAAD,CAAP;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,cAAD,CAArB;;AAEA,MAAME,cAAc,GAAG;AACrBC,EAAAA,OAAO,EAAE;AACP,oBAAgB,kBADT;AAEP,cAAU;AAFH;AADY,CAAvB;;AAOA,MAAMC,GAAG,GAAG,CAACC,KAAD,EAAQC,OAAR,EAAiBC,KAAjB,KAA2B,OAAOC,IAAP,EAAaC,OAAO,GAAG,EAAvB,KAA8B;AACnE,MAAI,OAAOJ,KAAK,CAACG,IAAD,CAAZ,KAAuB,WAA3B,EAAwC,OAAOH,KAAK,CAACG,IAAD,CAAL,CAAYE,IAAnB;AAExC,QAAMC,IAAI,GAAG,MAAMC,KAAK,CAACJ,IAAD,EAAOP,KAAK,CAACQ,OAAD,EAAU;AAAEN,IAAAA,OAAO,EAAE;AAAEI,MAAAA;AAAF;AAAX,GAAV,EAAkCL,cAAlC,CAAZ,CAAxB;AACA,QAAMW,IAAI,GAAG,MAAMF,IAAI,CAACE,IAAL,EAAnB,CAJmE,CAMnE;;AACA,QAAMC,SAAS,GAAGC,UAAU,CAAC,MAAM;AAAE,WAAOV,KAAK,CAACG,IAAD,CAAZ;AAAqB,GAA9B,EAAgCF,OAAhC,CAA5B;AAEAD,EAAAA,KAAK,CAACG,IAAD,CAAL,GAAc;AACZF,IAAAA,OAAO,EAAEQ,SADG;AAEZJ,IAAAA,IAAI,EAAEG;AAFM,GAAd;AAIA,SAAOA,IAAP;AACD,CAdD;;AAgBA,MAAMG,IAAI,GAAGT,KAAK,IAAI,OAAOC,IAAP,EAAaE,IAAb,EAAmBD,OAAO,GAAG,EAA7B,KAAoC;AACxD,QAAME,IAAI,GAAG,MAAMC,KAAK,CAACJ,IAAD,EAAOP,KAAK,CAACQ,OAAD,EAAU;AAC5CQ,IAAAA,MAAM,EAAE,MADoC;AAE5Cd,IAAAA,OAAO,EAAE;AAAEI,MAAAA,KAAK,EAAG,SAAQA,KAAM;AAAxB,KAFmC;AAG5CW,IAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAeV,IAAf;AAHsC,GAAV,EAIjCR,cAJiC,CAAZ,CAAxB;AAKA,QAAMW,IAAI,GAAG,MAAMF,IAAI,CAACE,IAAL,EAAnB;AACA,SAAOA,IAAP;AACD,CARD;;AAUA,MAAMQ,KAAK,GAAGd,KAAK,IAAI,OAAOC,IAAP,EAAaE,IAAb,EAAmBD,OAAO,GAAG,EAA7B,KAAoC;AACzD,QAAME,IAAI,GAAG,MAAMC,KAAK,CAACJ,IAAD,EAAOP,KAAK,CAACQ,OAAD,EAAU;AAC5CQ,IAAAA,MAAM,EAAE,OADoC;AAE5Cd,IAAAA,OAAO,EAAE;AACPI,MAAAA,KAAK,EAAG,SAAQA,KAAM;AADf,KAFmC;AAK5CW,IAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAeV,IAAf;AALsC,GAAV,EAMjCR,cANiC,CAAZ,CAAxB;AAOA,QAAMW,IAAI,GAAG,MAAMF,IAAI,CAACE,IAAL,EAAnB;AACA,SAAOA,IAAP;AACD,CAVD;;AAYAS,MAAM,CAACC,OAAP,GAAiB,CAAClB,KAAD,EAAQC,OAAR,EAAiBC,KAAjB,MAA4B;AAC3CH,EAAAA,GAAG,EAAEA,GAAG,CAACC,KAAD,EAAQC,OAAR,EAAiBC,KAAjB,CADmC;AAE3CS,EAAAA,IAAI,EAAEA,IAAI,CAACT,KAAD,CAFiC;AAG3Cc,EAAAA,KAAK,EAAEA,KAAK,CAACd,KAAD;AAH+B,CAA5B,CAAjB","sourcesContent":["require('./fetchLoader');\nconst merge = require('lodash/merge');\n\nconst defaultHeaders = {\n  headers: {\n    'content-type': 'application/json',\n    'accept': 'application/json'\n  }\n};\n\nconst get = (cache, timeout, token) => async (path, options = {}) => {\n  if (typeof cache[path] !== 'undefined') return cache[path].data;\n  \n  const resp = await fetch(path, merge(options, { headers: { token } }, defaultHeaders));\n  const json = await resp.json();\n\n  // saves timeoutID for purging timers\n  const timeoutID = setTimeout(() => { delete cache[path]; }, timeout);\n\n  cache[path] = {\n    timeout: timeoutID,\n    data: json\n  };\n  return json;\n}\n\nconst post = token => async (path, data, options = {}) => {\n  const resp = await fetch(path, merge(options, {\n    method: 'POST',\n    headers: { token: `Token ${token}` },\n    body: JSON.stringify(data)\n  }, defaultHeaders));\n  const json = await resp.json();\n  return json;\n}\n\nconst patch = token => async (path, data, options = {}) => {\n  const resp = await fetch(path, merge(options, {\n    method: 'PATCH',\n    headers: {\n      token: `Token ${token}`\n    },\n    body: JSON.stringify(data)\n  }, defaultHeaders));\n  const json = await resp.json();\n  return json;\n}\n\nmodule.exports = (cache, timeout, token) => ({\n  get: get(cache, timeout, token),\n  post: post(token),\n  patch: patch(token)\n});\n"]},"metadata":{},"sourceType":"script"}